# HTTPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå®Ÿè£…æ‰‹é †æ›¸

## æ¦‚è¦

ChatPanel.tsxã®HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‹å®‰å…¨ã§ä¿å®ˆæ€§ã®é«˜ã„apiclientã€httpclientã‚¯ãƒ©ã‚¹ã«åˆ†é›¢ã—ã€neverthrowã‚’ä½¿ã£ãŸã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’å®Ÿè£…ã™ã‚‹ã€‚

## ç¾åœ¨ã®çŠ¶æ³åˆ†æ

### ç¾åœ¨ã®HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆ
- **GET** `/api/chat/status` - MCPæ¥ç¶šçŠ¶æ…‹ç¢ºèª
- **POST** `/api/chat/connect` - MCPæ¥ç¶š
- **POST** `/api/chat` - ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡

### å•é¡Œç‚¹
- ç›´æ¥fetchã‚’ä½¿ç”¨ã—ã¦ãŠã‚Šã€å‹å®‰å…¨æ€§ãŒä¸ååˆ†
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒtry-catchã§åˆ†æ•£ã—ã¦ã„ã‚‹
- HTTPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®è¨­å®šãŒé‡è¤‡ã—ã¦ã„ã‚‹
- ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å‹å®šç¾©ãŒä¸æ˜ç¢º

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ

```mermaid
graph TB
    A[ChatPanel.tsx] --> B[ChatApiClient]
    B --> C[HttpClient]
    C --> D[Backend API]

    B --> E[å‹å®šç¾©]
    E --> F[ChatStatusResponse]
    E --> G[ChatConnectResponse]
    E --> H[ChatMessageResponse]
    E --> I[ChatMessageRequest]

    C --> J[neverthrow Result]
    J --> K[Success Response]
    J --> L[Error Response]

    subgraph "ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°"
        M[HttpError]
        N[NetworkError]
        O[ValidationError]
    end

    C --> M
    C --> N
    C --> O
```

## å®Ÿè£…æ‰‹é †

### 1. ä¾å­˜é–¢ä¿‚ã®è¿½åŠ 

```bash
cd frontend
npm install neverthrow
npm install --save-dev @types/node
```

### 2. ã‚¨ãƒ©ãƒ¼å‹ã®å®šç¾©

**ãƒ•ã‚¡ã‚¤ãƒ«**: `frontend/src/lib/errors.ts`

```typescript
export type HttpErrorType =
  | 'NETWORK_ERROR'
  | 'VALIDATION_ERROR'
  | 'SERVER_ERROR'
  | 'UNKNOWN_ERROR';

export interface HttpError {
  type: HttpErrorType;
  message: string;
  status?: number;
  details?: unknown;
}

export const createHttpError = (
  type: HttpErrorType,
  message: string,
  status?: number,
  details?: unknown
): HttpError => ({
  type,
  message,
  status,
  details,
});

export const createNetworkError = (message: string, details?: unknown): HttpError =>
  createHttpError('NETWORK_ERROR', message, undefined, details);

export const createValidationError = (message: string, details?: unknown): HttpError =>
  createHttpError('VALIDATION_ERROR', message, 400, details);

export const createServerError = (message: string, status: number, details?: unknown): HttpError =>
  createHttpError('SERVER_ERROR', message, status, details);

export const createUnknownError = (message: string, details?: unknown): HttpError =>
  createHttpError('UNKNOWN_ERROR', message, undefined, details);
```

### 3. å‹å®šç¾©ã®ä½œæˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `frontend/src/types/api.ts`

```typescript
export interface OpenAIMessage {
  role: "user" | "assistant" | "system" | "function";
  content: string | null;
  name?: string;
  function_call?: {
    name: string;
    arguments: string;
  };
}

export interface ChatMessageRequest {
  message: string;
  history: OpenAIMessage[];
  branchId?: string | null;
  fileContent?: string | null;
  userName?: string | null;
  filePath?: string | null;
}

export interface ChatMessageResponse {
  response: string;
}

export interface ChatStatusResponse {
  initialized: boolean;
  tools: unknown[];
}

export interface ChatConnectResponse {
  success: boolean;
  message: string;
}

export interface ApiErrorResponse {
  error: string;
  details?: string;
}
```

### 4. HttpClientã‚¯ãƒ©ã‚¹ã®å®Ÿè£…

**ãƒ•ã‚¡ã‚¤ãƒ«**: `frontend/src/lib/httpClient.ts`

```typescript
import { Result, ok, err } from 'neverthrow';
import type { HttpError } from './errors';
import {
  createNetworkError,
  createServerError,
  createUnknownError,
  createValidationError,
} from './errors';

export interface RequestOptions {
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  headers?: Record<string, string>;
  body?: unknown;
}

export class HttpClient {
  private baseUrl: string;
  private defaultHeaders: Record<string, string>;

  constructor(
    baseUrl: string,
    defaultHeaders: Record<string, string> = { 'Content-Type': 'application/json' }
  ) {
    this.baseUrl = baseUrl;
    this.defaultHeaders = defaultHeaders;
  }

  async request<T>(
    endpoint: string,
    options: RequestOptions = {}
  ): Promise<Result<T, HttpError>> {
    const url = `${this.baseUrl}${endpoint}`;

    const headers = {
      ...this.defaultHeaders,
      ...options.headers,
    };

    const requestInit: RequestInit = {
      method: options.method ?? 'GET',
      headers,
    };

    if (options.body && options.method !== 'GET') {
      requestInit.body = JSON.stringify(options.body);
    }

    try {
      const response = await fetch(url, requestInit);

      if (!response.ok) {
        const errorData = await this.parseErrorResponse(response);
        return err(createServerError(
          errorData.error || `HTTP ${response.status}: ${response.statusText}`,
          response.status,
          errorData
        ));
      }

      const data = await response.json();
      return ok(data as T);

    } catch (error) {
      if (error instanceof Error) {
        return err(createNetworkError('Network request failed', error));
      }
      return err(createUnknownError('Unknown error occurred', error));
    }
  }

  async get<T>(endpoint: string, options: Omit<RequestOptions, 'method' | 'body'> = {}): Promise<Result<T, HttpError>> {
    return this.request<T>(endpoint, { ...options, method: 'GET' });
  }

  async post<T>(endpoint: string, body?: unknown, options: Omit<RequestOptions, 'method' | 'body'> = {}): Promise<Result<T, HttpError>> {
    return this.request<T>(endpoint, { ...options, method: 'POST', body });
  }

  async put<T>(endpoint: string, body?: unknown, options: Omit<RequestOptions, 'method' | 'body'> = {}): Promise<Result<T, HttpError>> {
    return this.request<T>(endpoint, { ...options, method: 'PUT', body });
  }

  async delete<T>(endpoint: string, options: Omit<RequestOptions, 'method' | 'body'> = {}): Promise<Result<T, HttpError>> {
    return this.request<T>(endpoint, { ...options, method: 'DELETE' });
  }

  private async parseErrorResponse(response: Response): Promise<{ error: string; details?: string }> {
    try {
      const data = await response.json();
      return data;
    } catch {
      return { error: response.statusText };
    }
  }
}
```

### 5. ChatApiClientã‚¯ãƒ©ã‚¹ã®å®Ÿè£…

**ãƒ•ã‚¡ã‚¤ãƒ«**: `frontend/src/lib/chatApiClient.ts`

```typescript
import { Result, ok, err } from 'neverthrow';
import { HttpClient } from './httpClient';
import type { HttpError } from './errors';
import { createValidationError } from './errors';
import type {
  ChatMessageRequest,
  ChatMessageResponse,
  ChatStatusResponse,
  ChatConnectResponse,
} from '../types/api';

export class ChatApiClient {
  private httpClient: HttpClient;

  constructor(baseUrl: string) {
    this.httpClient = new HttpClient(baseUrl);
  }

  async getStatus(): Promise<Result<ChatStatusResponse, HttpError>> {
    return this.httpClient.get<ChatStatusResponse>('/chat/status');
  }

  async connect(): Promise<Result<ChatConnectResponse, HttpError>> {
    return this.httpClient.post<ChatConnectResponse>('/chat/connect');
  }

  async sendMessage(request: ChatMessageRequest): Promise<Result<ChatMessageResponse, HttpError>> {
    const validationResult = this.validateChatMessageRequest(request);
    if (validationResult.isErr()) {
      return err(validationResult.error);
    }

    return this.httpClient.post<ChatMessageResponse>('/chat', request);
  }

  private validateChatMessageRequest(request: ChatMessageRequest): Result<void, HttpError> {
    if (!request.message || typeof request.message !== 'string') {
      return err(createValidationError('Message is required and must be a string'));
    }

    if (request.message.trim() === '') {
      return err(createValidationError('Message cannot be empty'));
    }

    if (request.history && !Array.isArray(request.history)) {
      return err(createValidationError('History must be an array'));
    }

    if (request.branchId && typeof request.branchId !== 'string') {
      return err(createValidationError('branchId must be a string if provided'));
    }

    if (request.fileContent && typeof request.fileContent !== 'string') {
      return err(createValidationError('fileContent must be a string if provided'));
    }

    if (request.userName && typeof request.userName !== 'string') {
      return err(createValidationError('userName must be a string if provided'));
    }

    if (request.filePath && typeof request.filePath !== 'string') {
      return err(createValidationError('filePath must be a string if provided'));
    }

    return ok(undefined);
  }
}
```

### 6. APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä½œæˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `frontend/src/lib/api.ts`

```typescript
import { ChatApiClient } from './chatApiClient';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || "http://localhost:3001/api";

export const chatApiClient = new ChatApiClient(API_BASE_URL);
```

### 7. ChatPanel.tsxã®ä¿®æ­£

**ä¿®æ­£å¯¾è±¡**: `frontend/src/components/chat/ChatPanel.tsx`

#### 7.1 ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®ä¿®æ­£

```typescript
// æ—¢å­˜ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«è¿½åŠ 
import { chatApiClient } from "../../lib/api";
import type { ChatMessageRequest, OpenAIMessage } from "../../types/api";
import type { HttpError } from "../../lib/errors";
```

#### 7.2 API_BASE_URLã®å‰Šé™¤

```typescript
// å‰Šé™¤
// const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || "http://localhost:3001/api";
```

#### 7.3 OpenAIMessageã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®å‰Šé™¤

```typescript
// å‰Šé™¤ï¼ˆtypes/api.tsã«ç§»å‹•æ¸ˆã¿ï¼‰
// interface OpenAIMessage {
//   role: "user" | "assistant" | "system" | "function";
//   content: string | null;
//   name?: string;
//   function_call?: {
//     name: string;
//     arguments: string;
//   };
// }
```

#### 7.4 checkConnectionStatusé–¢æ•°ã®ä¿®æ­£

```typescript
const checkConnectionStatus = async (): Promise<boolean> => {
  const result = await chatApiClient.getStatus();

  if (result.isErr()) {
    console.error("æ¥ç¶šã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®ç¢ºèªã«å¤±æ•—ã—ã¾ã—ãŸ:", result.error);
    setIsConnected(false);
    return false;
  }

  const status = result.value.initialized;
  setIsConnected(status);
  return status;
};
```

#### 7.5 connectToGithubContributionServeré–¢æ•°ã®ä¿®æ­£

```typescript
const connectToGithubContributionServer = async () => {
  setIsLoading(true);
  setError(null);

  const result = await chatApiClient.connect();

  if (result.isErr()) {
    const errorMessage = result.error.message || "ã‚µãƒ¼ãƒãƒ¼ã¸ã®æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ";
    setError(errorMessage);
    setIsConnected(false);
  } else {
    setIsConnected(true);
  }

  setIsLoading(false);
};
```

#### 7.6 handleSendMessageé–¢æ•°ã®ä¿®æ­£

```typescript
const handleSendMessage = async () => {
  if (
    inputValue.trim() === "" ||
    !isMdFileActive ||
    !currentPath ||
    !currentThread
  )
    return;

  if (!userName) {
    const name = prompt(
      "ãŠåå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆã‚ãªãŸã®ææ¡ˆã®è¨˜åã«ä½¿ç”¨ã•ã‚Œã¾ã™ï¼‰ï¼š"
    );
    if (name) {
      setUserName(name);
      localStorage.setItem("userName", name);
    } else {
      console.warn("ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒåå‰ã‚’æä¾›ã—ã¾ã›ã‚“ã§ã—ãŸã€‚");
      setUserName("åŒ¿åãƒ¦ãƒ¼ã‚¶ãƒ¼");
      localStorage.setItem("userName", "åŒ¿åãƒ¦ãƒ¼ã‚¶ãƒ¼");
    }
  }

  const userMessageContent = {
    text: inputValue,
    sender: "user" as const,
  };

  addMessageToThread(currentPath, userMessageContent);

  const userInput = inputValue;
  setInputValue("");
  setIsLoading(true);
  setError(null);

  const historyForAPI: OpenAIMessage[] = currentThread.messages.map(
    (msg) => ({
      role: msg.sender === "user" ? "user" : "assistant",
      content: msg.text,
    })
  );
  historyForAPI.push({ role: "user", content: userInput });

  let fileContent: string | null = null;
  if (contentType === "file" && content && "content" in content) {
    try {
      fileContent = decodeBase64Content((content as GitHubFile).content);
    } catch (e) {
      console.error("ãƒ•ã‚¡ã‚¤ãƒ«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ:", e);
    }
  }

  const request: ChatMessageRequest = {
    message: userInput,
    history: historyForAPI,
    branchId: currentBranchId,
    fileContent: fileContent,
    userName: userName,
    filePath: currentPath,
  };

  const result = await chatApiClient.sendMessage(request);

  if (result.isErr()) {
    const errorMessage = result.error.message || "å¿œç­”ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ";
    setError(errorMessage);
    addMessageToThread(currentPath, {
      text: `ã‚¨ãƒ©ãƒ¼ï¼š${errorMessage}`,
      sender: "bot",
    });
    setIsLoading(false);
    return; // æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
  }

  // æˆåŠŸæ™‚ã®å‡¦ç†
  addMessageToThread(currentPath, {
    text: result.value.response,
    sender: "bot"
  });
  console.log("ãƒœãƒƒãƒˆã®å¿œç­”ã‚’å—ä¿¡ã—ã¾ã—ãŸã€‚ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ã„ã¾ã™...");
  reloadCurrentContent();
  setIsLoading(false);
};
```

## ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æˆ¦ç•¥

### neverthrowã®ä½¿ç”¨æ–¹é‡

1. **matchã¯ä½¿ç”¨ã—ãªã„**: èª­ã¿æ‰‹ã®è² è·ã‚’è»½æ¸›ã™ã‚‹ãŸã‚
2. **æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³**: `result.isErr()`ã§ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯å¾Œã€æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
3. **éšå±¤åŒ–ã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼**: HttpErrorå‹ã§çµ±ä¸€ã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼æƒ…å ±

### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®ä¾‹

```typescript
// è‰¯ã„ä¾‹ï¼šæ—©æœŸãƒªã‚¿ãƒ¼ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³
const result = await chatApiClient.sendMessage(request);
if (result.isErr()) {
  console.error("ã‚¨ãƒ©ãƒ¼:", result.error);
  return; // æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
}

// æˆåŠŸæ™‚ã®å‡¦ç†
const response = result.value;
console.log("æˆåŠŸ:", response);

// æ‚ªã„ä¾‹ï¼šmatchã®ä½¿ç”¨ï¼ˆé¿ã‘ã‚‹ï¼‰
// result.match(
//   (success) => console.log("æˆåŠŸ:", success),
//   (error) => console.error("ã‚¨ãƒ©ãƒ¼:", error)
// );
```

## ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### å˜ä½“ãƒ†ã‚¹ãƒˆ

1. **HttpClient**ã®ãƒ†ã‚¹ãƒˆ
   - æ­£å¸¸ãªãƒ¬ã‚¹ãƒãƒ³ã‚¹
   - ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹
   - ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼
   - ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ

2. **ChatApiClient**ã®ãƒ†ã‚¹ãƒˆ
   - ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
   - APIã‚³ãƒ¼ãƒ«
   - ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

### çµ±åˆãƒ†ã‚¹ãƒˆ

1. **ChatPanel**ã¨ã®çµ±åˆ
2. **å®Ÿéš›ã®API**ã¨ã®é€šä¿¡ãƒ†ã‚¹ãƒˆ

## å®Ÿè£…é †åº

1. âœ… ä¾å­˜é–¢ä¿‚ã®è¿½åŠ 
2. âœ… ã‚¨ãƒ©ãƒ¼å‹ã®å®šç¾©
3. âœ… å‹å®šç¾©ã®ä½œæˆ
4. âœ… HttpClientã‚¯ãƒ©ã‚¹ã®å®Ÿè£…
5. âœ… ChatApiClientã‚¯ãƒ©ã‚¹ã®å®Ÿè£…
6. âœ… APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä½œæˆ
7. âœ… ChatPanel.tsxã®ä¿®æ­£
8. ğŸ”„ ãƒ†ã‚¹ãƒˆã®å®Ÿè£…
9. ğŸ”„ å‹•ä½œç¢ºèª

## æ³¨æ„äº‹é …

1. **å‹å®‰å…¨æ€§**: TypeScriptã®å‹ãƒã‚§ãƒƒã‚¯ã‚’æœ€å¤§é™æ´»ç”¨
2. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**: neverthrowã®Resultã‚’ä¸€è²«ã—ã¦ä½¿ç”¨
3. **ä¿å®ˆæ€§**: å„ã‚¯ãƒ©ã‚¹ã®è²¬å‹™ã‚’æ˜ç¢ºã«åˆ†é›¢
4. **ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£**: ä¾å­˜æ€§æ³¨å…¥ã‚’è€ƒæ…®ã—ãŸè¨­è¨ˆ
5. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: ä¸è¦ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é¿ã‘ã‚‹

## æœŸå¾…ã•ã‚Œã‚‹åŠ¹æœ

1. **å‹å®‰å…¨æ€§ã®å‘ä¸Š**: ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã®ã‚¨ãƒ©ãƒ¼æ¤œå‡º
2. **ä¿å®ˆæ€§ã®å‘ä¸Š**: è²¬å‹™ã®åˆ†é›¢ã¨ã‚³ãƒ¼ãƒ‰ã®æ•´ç†
3. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®çµ±ä¸€**: ä¸€è²«ã—ãŸã‚¨ãƒ©ãƒ¼å‡¦ç†
4. **ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£ã®å‘ä¸Š**: å˜ä½“ãƒ†ã‚¹ãƒˆã®å®¹æ˜“æ€§
5. **é–‹ç™ºåŠ¹ç‡ã®å‘ä¸Š**: å†åˆ©ç”¨å¯èƒ½ãªã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
